#include <iostream>
#include <string>

using namespace std;

//***************************************** 内存模型 ************************************
//四区：全局区，代码区，栈区，堆区；
//注意事项： 全局区是由程序自动释放，即关闭程序才会释放，
//代码区，仅存放代码，共享的，只读的,
//全局区：全局变量，静态变量（加static关键词），包含了常量区（字符串常量，其他常量）
//栈区：运行后划分的区域，函数的参数，局部变量，注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放
//堆区: 由程序员分配释放，关键词 new,delete;如： int *a = new int(10);delete a;释放了指针P指向的堆区地址上的内存
//堆区：开辟数组： int * arr = new int[10]; delete[] arr,注意[]



//******************************************* 引用 *******************************************
//1.注意调用函数不要返回局部变量，因为局部变量是存在在栈区，调用完后就把内存给释放了。
//2.函数是可以返回引用的，也就是说可以将函数的返回值以引用的方式返回。
//3.函数调用是可以做左值的，前提是必须是引用的。 
//4.除了值传递，除了地址传递，还有最后一种用引用传递参数的，这种方式是可以用形参更改实参的。
//引用的本质是指针常量， 即 int * const p; 是能改值，不能改地址，也就是说引用可以改原名变量的地址的值。
//不能够更改引用所代表的地址，所以引用不能变更引用对象，因为他是const的。
//也就是指针是手动挡，引用是自动挡。

//******************************************* 函数提高 *******************************************
//1.函数的默认参数 void func(int a = 10),调用的时候就可以直接func();不用设置实参；
//注意：①：设置了默认参数的后面的参数也必须设置默认参数；
//②：若传递了实参，则实参优先级高于默认参数；
//③：函数声明和函数定义只能有一个存才默认参数；（避免二义性）

//2.函数的占用参数，void func(int a, int)，重载可以用

//3.函数重载，提高函数复用率
//①：函数重载条件：函数名一样；同一个作用域下；函数的参数类型不同，或这个数不同，或者顺序不同；总而言之，避免二义性；
//注意事项： ①，引用可以作为函数重载条件；详见第98集5分10秒，加const作区分
// ②： 函数重载遇到函数默认参数，出现二义性，报错。要重载就不要写默认参数；


int& t(void) //&t()代表的就是a的地址的值
{
	//int a = 10;
	static int a = 10;
	cout << "***********" << "t(a) = " << a << "***********"<< endl ;
	return a;
}

int main(void)
{
	int c = 1;
	int& c1 = c;	//也就是int * const c1 = &c;
	c1 = 10;		//也就是*c1 = 10;

	int& p = t();
	cout << "p = " << p << endl;
	t() = 1000;
	t();
	cout << "p = " << p << endl;
	cout << "p = " << p << endl;
	cout << "p = " << p << endl;
	cout << "p = " << p << endl;
	return 0;
}